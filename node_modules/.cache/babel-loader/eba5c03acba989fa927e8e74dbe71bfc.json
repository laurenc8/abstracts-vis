{"ast":null,"code":"import { createElement, createRef, forwardRef, useState, useImperativeHandle, useRef } from 'react';\nimport * as styleAttr from 'style-attr';\nimport querySelectorAll from 'query-selector';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_POSITION = {\n  DISCONNECTED: 1,\n  PRECEDING: 2,\n  FOLLOWING: 4,\n  CONTAINS: 8,\n  CONTAINED_BY: 16,\n  IMPLEMENTATION_SPECIFIC: 32\n};\nvar EVENT_NAME_MAPPING = {\n  blur: \"onBlur\",\n  change: \"onChange\",\n  click: \"onClick\",\n  contextmenu: \"onContextMenu\",\n  copy: \"onCopy\",\n  cut: \"onCut\",\n  doubleclick: \"onDoubleClick\",\n  drag: \"onDrag\",\n  dragend: \"onDragEnd\",\n  dragenter: \"onDragEnter\",\n  dragexit: \"onDragExit\",\n  dragleave: \"onDragLeave\",\n  dragover: \"onDragOver\",\n  dragstart: \"onDragStart\",\n  drop: \"onDrop\",\n  error: \"onError\",\n  focus: \"onFocus\",\n  input: \"onInput\",\n  keydown: \"onKeyDown\",\n  keypress: \"onKeyPress\",\n  keyup: \"onKeyUp\",\n  load: \"onLoad\",\n  mousedown: \"onMouseDown\",\n  mouseenter: \"onMouseEnter\",\n  mouseleave: \"onMouseLeave\",\n  mousemove: \"onMouseMove\",\n  mouseout: \"onMouseOut\",\n  mouseover: \"onMouseOver\",\n  mouseup: \"onMouseUp\",\n  paste: \"onPaste\",\n  scroll: \"onScroll\",\n  submit: \"onSubmit\",\n  touchcancel: \"onTouchCancel\",\n  touchend: \"onTouchEnd\",\n  touchmove: \"onTouchMove\",\n  touchstart: \"onTouchStart\",\n  wheel: \"onWheel\"\n};\nvar HYPHEN_EXP = /-+([a-z])/gi;\n\nfunction camelCase(str) {\n  var camelCased = str.replace(HYPHEN_EXP, function (match, c, offset) {\n    if (offset !== 0) {\n      return c.toUpperCase();\n    } else {\n      return c;\n    }\n  });\n  HYPHEN_EXP.lastIndex = 0;\n  return camelCased;\n}\n\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n\nvar eventToPropName = function eventToPropName(name) {\n  return EVENT_NAME_MAPPING[name] || \"on\" + name.slice(0, 1).toUpperCase() + name.slice(1);\n};\n\nvar SKIP_ATTR_EXP = [/^data-/, /^aria-/];\n\nvar attrToPropName = function attrToPropName(name) {\n  if (SKIP_ATTR_EXP.some(function (expr) {\n    return expr.test(name);\n  })) {\n    return name;\n  } else if (name === \"class\") {\n    return \"className\";\n  } else {\n    return camelCase(name);\n  }\n};\n\nfunction styleToPropName(name) {\n  var camel = camelCase(name); // Detect if the style property is already camelCased\n  // To not convert Webkit*, Moz* and O* to lowercase\n\n  if (camel.charAt(0).toUpperCase() === name.charAt(0)) {\n    return name.charAt(0) + camel.slice(1);\n  } else if (name.charAt(0) === \"-\") {\n    return camel.indexOf(\"ms\") === 0 ? camel : camel.charAt(0).toUpperCase() + camel.slice(1);\n  } else {\n    return camel;\n  }\n}\n\nvar generateId = function generateId() {\n  return Math.random().toString(36).substr(2, 9);\n};\n\nvar mapEventListener = function mapEventListener(self, listeners) {\n  return function (syntheticEvent) {\n    var event;\n\n    if (syntheticEvent) {\n      event = syntheticEvent.nativeEvent;\n      event.syntheticEvent = syntheticEvent;\n    }\n\n    listeners.forEach(function (listener) {\n      listener.call(self, event);\n    });\n  };\n};\n\nfunction isAncestor(source, target) {\n  while (target.parentNode) {\n    target = target.parentNode;\n\n    if (target === source) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getFirstNodeByOrder(nodes, nodeOne, nodeTwo) {\n  return nodes.reduce(function (result, node) {\n    if (result !== false) {\n      return result;\n    } else if (node === nodeOne) {\n      return nodeOne;\n    } else if (node === nodeTwo) {\n      return nodeTwo;\n    } else if (node.childNodes) {\n      return getFirstNodeByOrder(node.childNodes, nodeOne, nodeTwo);\n    } else {\n      return false;\n    }\n  }, false);\n}\n\nfunction eitherContains(left, right) {\n  return isAncestor(left, right) ? DOCUMENT_POSITION.CONTAINED_BY + DOCUMENT_POSITION.FOLLOWING : isAncestor(right, left) ? DOCUMENT_POSITION.CONTAINS + DOCUMENT_POSITION.PRECEDING : false;\n}\n\nfunction getRootNode(node) {\n  while (node.parentNode) {\n    node = node.parentNode;\n  }\n\n  return node;\n}\n\nvar FauxStyle =\n/** @class */\nfunction () {\n  function FauxStyle(ref, style) {\n    var _this = this;\n\n    if (style === void 0) {\n      style = {};\n    }\n\n    this.ref = createRef();\n\n    this.setProperty = function (name, value) {\n      var _a;\n\n      var hasUpdate = _this.getPropertyValue(name) !== value;\n      _this.style[styleToPropName(name)] = value;\n\n      if (hasUpdate) {\n        (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.style.setProperty(name, value);\n      }\n    };\n\n    this.getPropertyValue = function (name) {\n      var _a;\n\n      return (_a = _this.style[styleToPropName(name)]) !== null && _a !== void 0 ? _a : \"\";\n    };\n\n    this.removeProperty = function (name) {\n      var _a;\n\n      var key = styleToPropName(name);\n      var old = _this.style[key];\n      var hasUpdate = !isUndefined(old);\n      delete _this.style[key];\n\n      if (hasUpdate) {\n        (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.style.removeProperty(name);\n      }\n\n      return old !== null && old !== void 0 ? old : \"\";\n    };\n\n    this.ref = ref;\n    this.style = style;\n  }\n\n  return FauxStyle;\n}();\n\nvar D3Element =\n/** @class */\nfunction () {\n  function D3Element(nodeName, initialValues, isRoot) {\n    var _this = this;\n\n    if (isRoot === void 0) {\n      isRoot = false;\n    }\n\n    var _a, _b, _c;\n\n    this.ref = createRef();\n    this.mountRef = createRef();\n\n    this.setAttribute = function (name, value) {\n      var _a;\n\n      if (name === \"style\") {\n        if (isString(value)) {\n          var styles = styleAttr.parse(value);\n\n          for (var key in styles) {\n            _this.style.setProperty(key, styles[key]);\n          }\n        }\n      } else {\n        var hasUpdate = _this.getAttribute(name) !== value;\n        _this.attrs[attrToPropName(name)] = value;\n\n        if (hasUpdate) {\n          (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute(name, value);\n        }\n      }\n    };\n\n    this.setAttributeNS = function (ns) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      return _this.setAttribute.apply(_this, args);\n    };\n\n    this.getAttribute = function (name) {\n      return _this.attrs[attrToPropName(name)];\n    };\n\n    this.getAttributeNS = function (ns) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      return _this.getAttribute.apply(_this, args);\n    };\n\n    this.getAttributeNode = function (name) {\n      var value = _this.getAttribute(name);\n\n      if (!isUndefined(value)) {\n        return {\n          value: value,\n          specified: true\n        };\n      }\n\n      return null;\n    };\n\n    this.getAttributeNodeNS = function (ns) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      return _this.getAttributeNode.apply(_this, args);\n    };\n\n    this.removeAttribute = function (name) {\n      var _a;\n\n      var hasUpdate = !isUndefined(_this.attrs[attrToPropName(name)]);\n      delete _this.attrs[attrToPropName(name)];\n\n      if (hasUpdate) {\n        (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.removeAttribute(name);\n      }\n    };\n\n    this.removeAttributeNS = function (ns) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      return _this.removeAttribute.apply(_this, args);\n    };\n\n    this.addEventListener = function (name, fn) {\n      var prop = eventToPropName(name);\n      _this.eventListeners[prop] = _this.eventListeners[prop] || [];\n\n      _this.eventListeners[prop].push(fn);\n    };\n\n    this.removeEventListener = function (name, fn) {\n      var listeners = _this.eventListeners[eventToPropName(name)];\n\n      if (listeners) {\n        var match = listeners.indexOf(fn);\n\n        if (match !== -1) {\n          listeners.splice(match, 1);\n        }\n      }\n    };\n\n    this.getElementsByTagNameNS = function (ns, nodeName) {\n      return _this.getElementsByTagName(nodeName);\n    };\n\n    this.getElementByIdNS = function (ns, id) {\n      return _this.getElementById(id);\n    };\n\n    this.getBoundingClientRect = function () {\n      var _a;\n\n      return (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n    };\n\n    this.Mounter = forwardRef(function (props, ref) {\n      var _a = useState({});\n\n      _a[0];\n      var setFlush = _a[1];\n      useImperativeHandle(ref, function () {\n        return {\n          flush: function flush() {\n            return setFlush({});\n          }\n        };\n      }, [setFlush]);\n      return _this.renderElement();\n    });\n    this.id = generateId();\n    this.isRoot = isRoot;\n    this.nodeName = nodeName;\n    this.nodeType = (_a = initialValues === null || initialValues === void 0 ? void 0 : initialValues.nodeType) !== null && _a !== void 0 ? _a : ELEMENT_NODE;\n    this.parentNode = initialValues === null || initialValues === void 0 ? void 0 : initialValues.parentNode;\n    this.childNodes = [];\n    this.text = \"\";\n    this.attrs = (_b = initialValues === null || initialValues === void 0 ? void 0 : initialValues.attrs) !== null && _b !== void 0 ? _b : {};\n    this.style = new FauxStyle(this.ref, (_c = initialValues === null || initialValues === void 0 ? void 0 : initialValues.styles) !== null && _c !== void 0 ? _c : {});\n    this.eventListeners = {};\n  }\n\n  D3Element.prototype.getAttr = function () {\n    return _assign({}, this.attrs);\n  };\n\n  D3Element.prototype.getStyle = function () {\n    return _assign({}, this.style.style);\n  };\n\n  D3Element.prototype.appendChild = function (el) {\n    var _a;\n\n    if (el.parentNode) {\n      el.parentNode.removeChild(el);\n    }\n\n    el.parentNode = this;\n    this.childNodes.push(el);\n    (_a = this.mountRef.current) === null || _a === void 0 ? void 0 : _a.flush();\n    return el;\n  };\n\n  D3Element.prototype.insertBefore = function (el, before) {\n    var _a;\n\n    var index = this.childNodes.indexOf(before);\n    el.parentNode = this;\n\n    if (index !== -1) {\n      this.childNodes.splice(index, 0, el);\n    } else {\n      this.childNodes.push(el);\n    }\n\n    (_a = this.mountRef.current) === null || _a === void 0 ? void 0 : _a.flush();\n    return el;\n  };\n\n  D3Element.prototype.removeChild = function (child) {\n    var _a;\n\n    var target = this.childNodes.indexOf(child);\n    this.childNodes.splice(target, 1);\n    (_a = this.mountRef.current) === null || _a === void 0 ? void 0 : _a.flush();\n  };\n\n  D3Element.prototype.querySelector = function (selector) {\n    return this.querySelectorAll(selector)[0] || null;\n  };\n\n  D3Element.prototype.querySelectorAll = function (selector) {\n    if (!selector) {\n      throw new Error(\"Not enough arguments\");\n    }\n\n    return querySelectorAll(selector, this);\n  };\n\n  D3Element.prototype.getElementsByTagName = function (nodeName) {\n    var children = this.children;\n\n    if (children.length === 0) {\n      return [];\n    } else {\n      var matches = void 0;\n\n      if (nodeName !== \"*\") {\n        matches = children.filter(function (el) {\n          return el.nodeName === nodeName;\n        });\n      } else {\n        matches = children;\n      }\n\n      var childMatches = children.map(function (el) {\n        return el.getElementsByTagName(nodeName);\n      });\n      return matches.concat.apply(matches, childMatches);\n    }\n  };\n\n  D3Element.prototype.getElementById = function (id) {\n    var children = this.children;\n\n    if (children.length === 0) {\n      return null;\n    } else {\n      var match = children.find(function (el) {\n        return el.getAttribute(\"id\") === id;\n      });\n\n      if (match) {\n        return match;\n      } else {\n        var childMatches = children.map(function (el) {\n          return el.getElementById(id);\n        });\n        return childMatches.find(function (match) {\n          return match !== null;\n        }) || null;\n      }\n    }\n  };\n\n  D3Element.prototype.cloneNode = function (deep) {\n    if (deep === void 0) {\n      deep = true;\n    }\n\n    var el = new D3Element(this.nodeName, {\n      nodeType: this.nodeType,\n      parentNode: this.parentNode,\n      attrs: this.getAttr(),\n      styles: this.getStyle()\n    });\n\n    if (deep) {\n      el.childNodes = this.childNodes.map(function (c) {\n        var childEl = c.cloneNode(true);\n        childEl.parentNode = el;\n        return childEl;\n      });\n    }\n\n    return el;\n  };\n\n  D3Element.prototype.compareDocumentPosition = function (other) {\n    if (this === other) {\n      return 0;\n    }\n\n    var referenceRoot = getRootNode(this);\n    var otherRoot = getRootNode(other);\n\n    if (referenceRoot !== otherRoot) {\n      return DOCUMENT_POSITION.DISCONNECTED;\n    }\n\n    var result = eitherContains(this, other);\n\n    if (result) {\n      return result;\n    }\n\n    var first = getFirstNodeByOrder([referenceRoot], this, other);\n    return first === this ? DOCUMENT_POSITION.FOLLOWING : first === other ? DOCUMENT_POSITION.PRECEDING : DOCUMENT_POSITION.DISCONNECTED;\n  };\n\n  D3Element.prototype.createSVGPoint = function () {\n    var _a;\n\n    return (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.createSVGPoint();\n  };\n\n  D3Element.prototype.getScreenCTM = function () {\n    var _a;\n\n    return (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.getScreenCTM();\n  };\n\n  Object.defineProperty(D3Element.prototype, \"ownerDocument\", {\n    get: function get() {\n      return FauxDocument;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(D3Element.prototype, \"ownerSVGElement\", {\n    get: function get() {\n      var target = this;\n\n      while (target.parentNode) {\n        target = target.parentNode;\n\n        if (target.nodeName === \"svg\") {\n          return target;\n        }\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(D3Element.prototype, \"nextSibling\", {\n    get: function get() {\n      var _a;\n\n      var siblings = (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.children;\n      if (!siblings) return;\n      var me = siblings.indexOf(this);\n      return siblings[me + 1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(D3Element.prototype, \"previousSibling\", {\n    get: function get() {\n      var _a;\n\n      var siblings = (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.children;\n      if (!siblings) return;\n      var me = siblings.indexOf(this);\n      return siblings[me - 1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(D3Element.prototype, \"clientLeft\", {\n    get: function get() {\n      var _a;\n\n      return (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.clientLeft;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(D3Element.prototype, \"clientTop\", {\n    get: function get() {\n      var _a;\n\n      return (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.clientTop;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(D3Element.prototype, \"innerHTML\", {\n    get: function get() {\n      return this.text;\n    },\n    set: function set(text) {\n      this.text = text;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(D3Element.prototype, \"textContent\", {\n    get: function get() {\n      return this.text;\n    },\n    set: function set(text) {\n      this.text = text;\n\n      if (this.ref.current) {\n        this.ref.current.textContent = text;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(D3Element.prototype, \"children\", {\n    get: function get() {\n      // So far nodes created by this library are all of nodeType 1 (elements),\n      // but this could change in the future.\n      return this.childNodes.filter(function (el) {\n        if (!el.nodeType) {\n          // It's a React element, we always add it\n          return true;\n        } // It's a HTML node. We want to filter to have only nodes with type 1\n\n\n        return el.nodeType === ELEMENT_NODE;\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  D3Element.prototype.toReact = function () {\n    return createElement(this.Mounter, {\n      ref: this.mountRef,\n      key: this.id\n    });\n  };\n\n  D3Element.prototype.renderElement = function () {\n    var _this = this;\n\n    if (!this.isRoot && !this.parentNode) return null;\n    var attrs = this.getAttr();\n    var style = this.getStyle();\n    return createElement(this.nodeName, _assign(_assign(_assign({}, attrs), Object.keys(this.eventListeners).reduce(function (acc, k) {\n      acc[k] = mapEventListener(_this, _this.eventListeners[k]);\n      return acc;\n    }, {})), {\n      style: style,\n      ref: this.ref,\n      key: this.id\n    }), this.text || this.children.map(function (el) {\n      return el.toReact();\n    }));\n  };\n\n  return D3Element;\n}();\n\nvar FauxWindow = {\n  getComputedStyle: function getComputedStyle(node) {\n    return {\n      getPropertyValue: node.style.getPropertyValue\n    };\n  }\n};\nvar FauxDocument = {\n  Element: D3Element,\n  defaultView: FauxWindow,\n  createElement: function createElement(nodeName) {\n    return new D3Element(nodeName);\n  },\n  createElementNS: function createElementNS(ns, nodeName) {\n    return this.createElement(nodeName);\n  },\n  // The selector engine tries to validate with this, but we don't care.\n  // 8 = DOCUMENT_POSITION_CONTAINS, so we say all nodes are in this document.\n  compareDocumentPosition: function compareDocumentPosition() {\n    return DOCUMENT_POSITION.CONTAINS;\n  }\n};\n\nvar d3Element = function d3Element(name) {\n  return new D3Element(name, undefined, true);\n};\n\nvar useD3 = function useD3(recipe, deps) {\n  var resRef = useRef(null);\n  var depsRef = useRef(deps);\n\n  if (depsRef.current.length === deps.length && depsRef.current.every(function (d, i) {\n    return d === deps[i];\n  })) {\n    return resRef.current || (resRef.current = recipe(d3Element));\n  }\n\n  resRef.current = recipe(d3Element);\n  depsRef.current = deps;\n  return resRef.current;\n};\n\nexport { useD3 };","map":null,"metadata":{},"sourceType":"module"}