{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n/**\n * attr fix for old ie\n * @author yiminghe@gmail.com\n */\n\nvar R_BOOLEAN = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,\n    R_FOCUSABLE = /^(?:button|input|object|select|textarea)$/i,\n    R_CLICKABLE = /^a(?:rea)?$/i,\n    R_INVALID_CHAR = /:|^on/;\nvar attrFix = {},\n    propFix,\n    attrHooks = {\n  // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n  tabindex: {\n    get: function get(el) {\n      // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n      var attributeNode = el.getAttributeNode('tabindex');\n      return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : R_FOCUSABLE.test(el.nodeName) || R_CLICKABLE.test(el.nodeName) && el.href ? 0 : undefined;\n    }\n  }\n},\n    boolHook = {\n  get: function get(elem, name) {\n    // 转发到 prop 方法\n    return elem[propFix[name] || name] ? // 根据 w3c attribute , true 时返回属性名字符串\n    name.toLowerCase() : undefined;\n  }\n},\n    attrNodeHook = {};\nattrHooks.style = {\n  get: function get(el) {\n    return el.style.cssText;\n  }\n};\npropFix = {\n  hidefocus: 'hideFocus',\n  tabindex: 'tabIndex',\n  readonly: 'readOnly',\n  'for': 'htmlFor',\n  'class': 'className',\n  maxlength: 'maxLength',\n  cellspacing: 'cellSpacing',\n  cellpadding: 'cellPadding',\n  rowspan: 'rowSpan',\n  colspan: 'colSpan',\n  usemap: 'useMap',\n  frameborder: 'frameBorder',\n  contenteditable: 'contentEditable'\n};\nvar ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';\nvar doc = typeof document !== 'undefined' ? document : {};\n\nfunction numberify(s) {\n  var c = 0; // convert '1.2.3.4' to 1.234\n\n  return parseFloat(s.replace(/\\./g, function () {\n    return c++ === 0 ? '.' : '';\n  }));\n}\n\nfunction ieVersion() {\n  var m, v;\n\n  if ((m = ua.match(/MSIE ([^;]*)|Trident.*; rv(?:\\s|:)?([0-9.]+)/)) && (v = m[1] || m[2])) {\n    return doc.documentMode || numberify(v);\n  }\n}\n\nfunction mix(s, t) {\n  for (var p in t) {\n    s[p] = t[p];\n  }\n}\n\nfunction each(arr, fn) {\n  var i = 0,\n      l = arr.length;\n\n  for (; i < l; i++) {\n    if (fn(arr[i], i) === false) {\n      break;\n    }\n  }\n}\n\nvar ie = ieVersion();\n\nif (ie && ie < 8) {\n  attrHooks.style.set = function (el, val) {\n    el.style.cssText = val;\n  }; // get attribute value from attribute node for ie\n\n\n  mix(attrNodeHook, {\n    get: function get(elem, name) {\n      var ret = elem.getAttributeNode(name); // Return undefined if attribute node specified by user\n\n      return ret && ( // fix #100\n      ret.specified || ret.nodeValue) ? ret.nodeValue : undefined;\n    }\n  }); // ie6,7 不区分 attribute 与 property\n\n  mix(attrFix, propFix); // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\n  attrHooks.tabIndex = attrHooks.tabindex; // 不光是 href, src, 还有 rowspan 等非 mapping 属性，也需要用第 2 个参数来获取原始值\n  // 注意 colSpan rowSpan 已经由 propFix 转为大写\n\n  each(['href', 'src', 'width', 'height', 'colSpan', 'rowSpan'], function (name) {\n    attrHooks[name] = {\n      get: function get(elem) {\n        var ret = elem.getAttribute(name, 2);\n        return ret === null ? undefined : ret;\n      }\n    };\n  });\n  attrHooks.placeholder = {\n    get: function get(elem, name) {\n      return elem[name] || attrNodeHook.get(elem, name);\n    }\n  };\n}\n\nif (ie) {\n  var hrefFix = attrHooks.href = attrHooks.href || {};\n\n  hrefFix.set = function (el, val, name) {\n    var childNodes = el.childNodes,\n        b,\n        len = childNodes.length,\n        allText = len > 0;\n\n    for (len = len - 1; len >= 0; len--) {\n      if (childNodes[len].nodeType !== 3) {\n        allText = 0;\n      }\n    }\n\n    if (allText) {\n      b = el.ownerDocument.createElement('b');\n      b.style.display = 'none';\n      el.appendChild(b);\n    }\n\n    el.setAttribute(name, '' + val);\n\n    if (b) {\n      el.removeChild(b);\n    }\n  };\n}\n\nvar RE_TRIM = /^[\\s\\xa0]+|[\\s\\xa0]+$/g,\n    trim = String.prototype.trim;\nvar SPACE = ' ';\nvar getElementsByTagName;\n\ngetElementsByTagName = function getElementsByTagName(name, context) {\n  return context.getElementsByTagName(name);\n};\n\nif (doc.createElement) {\n  var div = doc.createElement('div');\n  div.appendChild(document.createComment(''));\n\n  if (div.getElementsByTagName('*').length) {\n    getElementsByTagName = function getElementsByTagName(name, context) {\n      var nodes = context.getElementsByTagName(name),\n          needsFilter = name === '*'; // <input id='length'>\n\n      if (needsFilter || typeof nodes.length !== 'number') {\n        var ret = [],\n            i = 0,\n            el;\n\n        while (el = nodes[i++]) {\n          if (!needsFilter || el.nodeType === 1) {\n            ret.push(el);\n          }\n        }\n\n        return ret;\n      } else {\n        return nodes;\n      }\n    };\n  }\n}\n\nvar compareNodeOrder = 'sourceIndex' in (doc && doc.documentElement || {}) ? function (a, b) {\n  return a.sourceIndex - b.sourceIndex;\n} : function (a, b) {\n  if (!a.compareDocumentPosition || !b.compareDocumentPosition) {\n    return a.compareDocumentPosition ? -1 : 1;\n  }\n\n  var bit = a.compareDocumentPosition(b) & 4;\n  return bit ? -1 : 1;\n};\nvar util = {\n  ie: ie,\n  unique: function () {\n    var hasDuplicate,\n        baseHasDuplicate = true; // Here we check if the JavaScript engine is using some sort of\n    // optimization where it does not always call our comparison\n    // function. If that is the case, discard the hasDuplicate value.\n    // Thus far that includes Google Chrome.\n\n    [0, 0].sort(function () {\n      baseHasDuplicate = false;\n      return 0;\n    });\n\n    function sortOrder(a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n        return 0;\n      }\n\n      return compareNodeOrder(a, b);\n    } // 排序去重\n\n\n    return function (elements) {\n      hasDuplicate = baseHasDuplicate;\n      elements.sort(sortOrder);\n\n      if (hasDuplicate) {\n        var i = 1,\n            len = elements.length;\n\n        while (i < len) {\n          if (elements[i] === elements[i - 1]) {\n            elements.splice(i, 1);\n            --len;\n          } else {\n            i++;\n          }\n        }\n      }\n\n      return elements;\n    };\n  }(),\n  getElementsByTagName: getElementsByTagName,\n  getSimpleAttr: function getSimpleAttr(el, name) {\n    var ret = el && el.getAttributeNode(name);\n\n    if (ret && ret.specified) {\n      return 'value' in ret ? ret.value : ret.nodeValue;\n    }\n\n    return undefined;\n  },\n  contains: ie ? function (a, b) {\n    if (a.nodeType === 9) {\n      a = a.documentElement;\n    } // !a.contains => a===document || text\n    // 注意原生 contains 判断时 a===b 也返回 true\n\n\n    b = b.parentNode;\n\n    if (a === b) {\n      return true;\n    } // when b is document, a.contains(b) 不支持的接口 in ie\n\n\n    if (b && b.nodeType === 1) {\n      return a.contains && a.contains(b);\n    } else {\n      return false;\n    }\n  } : function (a, b) {\n    return !!(a.compareDocumentPosition(b) & 16);\n  },\n  isTag: function isTag(el, value) {\n    return value === '*' || el.nodeName.toLowerCase() === value.toLowerCase();\n  },\n  hasSingleClass: function hasSingleClass(el, cls) {\n    // consider xml\n    // https://github.com/kissyteam/kissy/issues/532\n    var className = el && util.getSimpleAttr(el, 'class');\n    return className && (className = className.replace(/[\\r\\t\\n]/g, SPACE)) && (SPACE + className + SPACE).indexOf(SPACE + cls + SPACE) > -1;\n  },\n  startsWith: function startsWith(str, prefix) {\n    return str.lastIndexOf(prefix, 0) === 0;\n  },\n  endsWith: function endsWith(str, suffix) {\n    var ind = str.length - suffix.length;\n    return ind >= 0 && str.indexOf(suffix, ind) === ind;\n  },\n  trim: trim ? function (str) {\n    return str == null ? '' : trim.call(str);\n  } : function (str) {\n    return str == null ? '' : (str + '').replace(RE_TRIM, '');\n  },\n  attr: function attr(el, name) {\n    var attrNormalizer, ret; // scrollLeft\n\n    name = name.toLowerCase(); // custom attrs\n\n    name = attrFix[name] || name;\n\n    if (R_BOOLEAN.test(name)) {\n      attrNormalizer = boolHook;\n    } else if (R_INVALID_CHAR.test(name)) {\n      // only old ie?\n      attrNormalizer = attrNodeHook;\n    } else {\n      attrNormalizer = attrHooks[name];\n    }\n\n    if (el && el.nodeType === 1) {\n      // browsers index elements by id/name on forms, give priority to attributes.\n      if (el.nodeName.toLowerCase() === 'form') {\n        attrNormalizer = attrNodeHook;\n      }\n\n      if (attrNormalizer && attrNormalizer.get) {\n        return attrNormalizer.get(el, name);\n      }\n\n      ret = el.getAttribute(name);\n\n      if (ret === '') {\n        var attrNode = el.getAttributeNode(name);\n\n        if (!attrNode || !attrNode.specified) {\n          return undefined;\n        }\n      } // standard browser non-existing attribute return null\n      // ie<8 will return undefined , because it return property\n      // so norm to undefined\n\n\n      return ret === null ? undefined : ret;\n    }\n  }\n};\n/*\n  Generated by kison.*/\n\n/*jshint quotmark:false, loopfunc:true, indent:false, unused:false, asi:true, boss:true*/\n\n/* Generated by kison */\n\nvar parser = {},\n    GrammarConst = {\n  SHIFT_TYPE: 1,\n  REDUCE_TYPE: 2,\n  ACCEPT_TYPE: 0,\n  TYPE_INDEX: 0,\n  PRODUCTION_INDEX: 1,\n  TO_INDEX: 2\n};\n/*jslint quotmark: false*/\n\nfunction mix$1(to, from) {\n  for (var f in from) {\n    to[f] = from[f];\n  }\n}\n\nfunction isArray(obj) {\n  return '[object Array]' === Object.prototype.toString.call(obj);\n}\n\nfunction each$1(object, fn, context) {\n  if (object) {\n    var key,\n        val,\n        length,\n        i = 0;\n    context = context || null;\n\n    if (!isArray(object)) {\n      for (key in object) {\n        // can not use hasOwnProperty\n        if (fn.call(context, object[key], key, object) === false) {\n          break;\n        }\n      }\n    } else {\n      length = object.length;\n\n      for (val = object[0]; i < length; val = object[++i]) {\n        if (fn.call(context, val, i, object) === false) {\n          break;\n        }\n      }\n    }\n  }\n}\n\nfunction inArray(item, arr) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    if (arr[i] === item) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar Lexer = function Lexer(cfg) {\n  var self = this;\n  /*\n  lex rules.\n  @type {Object[]}\n  @example\n  [\n  {\n  regexp:'\\\\w+',\n  state:['xx'],\n  token:'c',\n  // this => lex\n  action:function(){}\n  }\n  ]\n  */\n\n  self.rules = [];\n  mix$1(self, cfg);\n  /*\n  Input languages\n  @type {String}\n  */\n\n  self.resetInput(self.input);\n};\n\nLexer.prototype = {\n  resetInput: function resetInput(input) {\n    mix$1(this, {\n      input: input,\n      matched: '',\n      stateStack: [Lexer.STATIC.INITIAL],\n      match: '',\n      text: '',\n      firstLine: 1,\n      lineNumber: 1,\n      lastLine: 1,\n      firstColumn: 1,\n      lastColumn: 1\n    });\n  },\n  getCurrentRules: function getCurrentRules() {\n    var self = this,\n        currentState = self.stateStack[self.stateStack.length - 1],\n        rules = []; //#JSCOVERAGE_IF\n\n    if (self.mapState) {\n      currentState = self.mapState(currentState);\n    }\n\n    each$1(self.rules, function (r) {\n      var state = r.state || r[3];\n\n      if (!state) {\n        if (currentState === Lexer.STATIC.INITIAL) {\n          rules.push(r);\n        }\n      } else if (inArray(currentState, state)) {\n        rules.push(r);\n      }\n    });\n    return rules;\n  },\n  pushState: function pushState(state) {\n    this.stateStack.push(state);\n  },\n  popState: function popState(num) {\n    num = num || 1;\n    var ret;\n\n    while (num--) {\n      ret = this.stateStack.pop();\n    }\n\n    return ret;\n  },\n  showDebugInfo: function showDebugInfo() {\n    var self = this,\n        DEBUG_CONTEXT_LIMIT = Lexer.STATIC.DEBUG_CONTEXT_LIMIT,\n        matched = self.matched,\n        match = self.match,\n        input = self.input;\n    matched = matched.slice(0, matched.length - match.length); //#JSCOVERAGE_IF 0\n\n    var past = (matched.length > DEBUG_CONTEXT_LIMIT ? '...' : '') + matched.slice(0 - DEBUG_CONTEXT_LIMIT).replace(/\\n/, ' '),\n        next = match + input; //#JSCOVERAGE_ENDIF\n\n    next = next.slice(0, DEBUG_CONTEXT_LIMIT) + (next.length > DEBUG_CONTEXT_LIMIT ? '...' : '');\n    return past + next + '\\n' + new Array(past.length + 1).join('-') + '^';\n  },\n  mapSymbol: function mapSymbolForCodeGen(t) {\n    return this.symbolMap[t];\n  },\n  mapReverseSymbol: function mapReverseSymbol(rs) {\n    var self = this,\n        symbolMap = self.symbolMap,\n        i,\n        reverseSymbolMap = self.reverseSymbolMap;\n\n    if (!reverseSymbolMap && symbolMap) {\n      reverseSymbolMap = self.reverseSymbolMap = {};\n\n      for (i in symbolMap) {\n        reverseSymbolMap[symbolMap[i]] = i;\n      }\n    } //#JSCOVERAGE_IF\n\n\n    if (reverseSymbolMap) {\n      return reverseSymbolMap[rs];\n    } else {\n      return rs;\n    }\n  },\n  lex: function lex() {\n    var self = this,\n        input = self.input,\n        i,\n        rule,\n        m,\n        ret,\n        lines,\n        rules = self.getCurrentRules();\n    self.match = self.text = '';\n\n    if (!input) {\n      return self.mapSymbol(Lexer.STATIC.END_TAG);\n    }\n\n    for (i = 0; i < rules.length; i++) {\n      rule = rules[i]; //#JSCOVERAGE_IF 0\n\n      var regexp = rule.regexp || rule[1],\n          token = rule.token || rule[0],\n          action = rule.action || rule[2] || undefined; //#JSCOVERAGE_ENDIF\n\n      if (m = input.match(regexp)) {\n        lines = m[0].match(/\\n.*/g);\n\n        if (lines) {\n          self.lineNumber += lines.length;\n        }\n\n        mix$1(self, {\n          firstLine: self.lastLine,\n          lastLine: self.lineNumber + 1,\n          firstColumn: self.lastColumn,\n          lastColumn: lines ? lines[lines.length - 1].length - 1 : self.lastColumn + m[0].length\n        });\n        var match; // for error report\n\n        match = self.match = m[0]; // all matches\n\n        self.matches = m; // may change by user\n\n        self.text = match; // matched content utils now\n\n        self.matched += match;\n        ret = action && action.call(self);\n\n        if (ret === undefined) {\n          ret = token;\n        } else {\n          ret = self.mapSymbol(ret);\n        }\n\n        input = input.slice(match.length);\n        self.input = input;\n\n        if (ret) {\n          return ret;\n        } else {\n          // ignore\n          return self.lex();\n        }\n      }\n    }\n  }\n};\nLexer.STATIC = {\n  INITIAL: 'I',\n  DEBUG_CONTEXT_LIMIT: 20,\n  END_TAG: '$EOF'\n};\nvar lexer = new Lexer({\n  rules: [['b', /^\\[(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['c', /^(?:[\\t\\r\\n\\f\\x20]*)\\]/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['d', /^(?:[\\t\\r\\n\\f\\x20]*)~=(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['e', /^(?:[\\t\\r\\n\\f\\x20]*)\\|=(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['f', /^(?:[\\t\\r\\n\\f\\x20]*)\\^=(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['g', /^(?:[\\t\\r\\n\\f\\x20]*)\\$=(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['h', /^(?:[\\t\\r\\n\\f\\x20]*)\\*=(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['i', /^(?:[\\t\\r\\n\\f\\x20]*)\\=(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['j', /^(?:(?:[\\w]|[^\\x00-\\xa0]|(?:\\\\[^\\n\\r\\f0-9a-f]))(?:[\\w\\d-]|[^\\x00-\\xa0]|(?:\\\\[^\\n\\r\\f0-9a-f]))*)\\(/, function () {\n    this.text = this.yy.trim(this.text).slice(0, -1);\n    this.pushState('fn');\n  }], ['k', /^[^\\)]*/, function () {\n    this.popState();\n  }, ['fn']], ['l', /^(?:[\\t\\r\\n\\f\\x20]*)\\)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['m', /^:not\\((?:[\\t\\r\\n\\f\\x20]*)/i, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['n', /^(?:(?:[\\w]|[^\\x00-\\xa0]|(?:\\\\[^\\n\\r\\f0-9a-f]))(?:[\\w\\d-]|[^\\x00-\\xa0]|(?:\\\\[^\\n\\r\\f0-9a-f]))*)/, function () {\n    this.text = this.yy.unEscape(this.text);\n  }], ['o', /^\"(\\\\\"|[^\"])*\"/, function () {\n    this.text = this.yy.unEscapeStr(this.text);\n  }], ['o', /^'(\\\\'|[^'])*'/, function () {\n    this.text = this.yy.unEscapeStr(this.text);\n  }], ['p', /^#(?:(?:[\\w\\d-]|[^\\x00-\\xa0]|(?:\\\\[^\\n\\r\\f0-9a-f]))+)/, function () {\n    this.text = this.yy.unEscape(this.text.slice(1));\n  }], ['q', /^\\.(?:(?:[\\w]|[^\\x00-\\xa0]|(?:\\\\[^\\n\\r\\f0-9a-f]))(?:[\\w\\d-]|[^\\x00-\\xa0]|(?:\\\\[^\\n\\r\\f0-9a-f]))*)/, function () {\n    this.text = this.yy.unEscape(this.text.slice(1));\n  }], ['r', /^(?:[\\t\\r\\n\\f\\x20]*),(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['s', /^::?/, 0], ['t', /^(?:[\\t\\r\\n\\f\\x20]*)\\+(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['u', /^(?:[\\t\\r\\n\\f\\x20]*)>(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['v', /^(?:[\\t\\r\\n\\f\\x20]*)~(?:[\\t\\r\\n\\f\\x20]*)/, function () {\n    this.text = this.yy.trim(this.text);\n  }], ['w', /^\\*/, 0], ['x', /^(?:[\\t\\r\\n\\f\\x20]+)/, 0], ['y', /^./, 0]]\n});\nparser.lexer = lexer;\nlexer.symbolMap = {\n  $EOF: 'a',\n  LEFT_BRACKET: 'b',\n  RIGHT_BRACKET: 'c',\n  INCLUDES: 'd',\n  DASH_MATCH: 'e',\n  PREFIX_MATCH: 'f',\n  SUFFIX_MATCH: 'g',\n  SUBSTRING_MATCH: 'h',\n  ALL_MATCH: 'i',\n  FUNCTION: 'j',\n  PARAMETER: 'k',\n  RIGHT_PARENTHESES: 'l',\n  NOT: 'm',\n  IDENT: 'n',\n  STRING: 'o',\n  HASH: 'p',\n  CLASS: 'q',\n  COMMA: 'r',\n  COLON: 's',\n  PLUS: 't',\n  GREATER: 'u',\n  TILDE: 'v',\n  UNIVERSAL: 'w',\n  S: 'x',\n  INVALID: 'y',\n  $START: 'z',\n  selectors_group: 'aa',\n  selector: 'ab',\n  simple_selector_sequence: 'ac',\n  combinator: 'ad',\n  type_selector: 'ae',\n  id_selector: 'af',\n  class_selector: 'ag',\n  attrib_match: 'ah',\n  attrib: 'ai',\n  attrib_val: 'aj',\n  pseudo: 'ak',\n  negation: 'al',\n  negation_arg: 'am',\n  suffix_selector: 'an',\n  suffix_selectors: 'ao'\n};\nparser.productions = [['z', ['aa']], ['aa', ['ab'], function () {\n  return [this.$1];\n}], ['aa', ['aa', 'r', 'ab'], function () {\n  this.$1.push(this.$3);\n}], ['ab', ['ac']], ['ab', ['ab', 'ad', 'ac'], function () {\n  // LinkedList\n  this.$1.nextCombinator = this.$3.prevCombinator = this.$2;\n  var order;\n  order = this.$1.order = this.$1.order || 0;\n  this.$3.order = order + 1;\n  this.$3.prev = this.$1;\n  this.$1.next = this.$3;\n  return this.$3;\n}], ['ad', ['t']], ['ad', ['u']], ['ad', ['v']], ['ad', ['x'], function () {\n  return ' ';\n}], ['ae', ['n'], function () {\n  return {\n    t: 'tag',\n    value: this.$1\n  };\n}], ['ae', ['w'], function () {\n  return {\n    t: 'tag',\n    value: this.$1\n  };\n}], ['af', ['p'], function () {\n  return {\n    t: 'id',\n    value: this.$1\n  };\n}], ['ag', ['q'], function () {\n  return {\n    t: 'cls',\n    value: this.$1\n  };\n}], ['ah', ['f']], ['ah', ['g']], ['ah', ['h']], ['ah', ['i']], ['ah', ['d']], ['ah', ['e']], ['ai', ['b', 'n', 'c'], function () {\n  return {\n    t: 'attrib',\n    value: {\n      ident: this.$2\n    }\n  };\n}], ['aj', ['n']], ['aj', ['o']], ['ai', ['b', 'n', 'ah', 'aj', 'c'], function () {\n  return {\n    t: 'attrib',\n    value: {\n      ident: this.$2,\n      match: this.$3,\n      value: this.$4\n    }\n  };\n}], ['ak', ['s', 'j', 'k', 'l'], function () {\n  return {\n    t: 'pseudo',\n    value: {\n      fn: this.$2.toLowerCase(),\n      param: this.$3\n    }\n  };\n}], ['ak', ['s', 'n'], function () {\n  return {\n    t: 'pseudo',\n    value: {\n      ident: this.$2.toLowerCase()\n    }\n  };\n}], ['al', ['m', 'am', 'l'], function () {\n  return {\n    t: 'pseudo',\n    value: {\n      fn: 'not',\n      param: this.$2\n    }\n  };\n}], ['am', ['ae']], ['am', ['af']], ['am', ['ag']], ['am', ['ai']], ['am', ['ak']], ['an', ['af']], ['an', ['ag']], ['an', ['ai']], ['an', ['ak']], ['an', ['al']], ['ao', ['an'], function () {\n  return [this.$1];\n}], ['ao', ['ao', 'an'], function () {\n  this.$1.push(this.$2);\n}], ['ac', ['ae']], ['ac', ['ao'], function () {\n  return {\n    suffix: this.$1\n  };\n}], ['ac', ['ae', 'ao'], function () {\n  return {\n    t: 'tag',\n    value: this.$1.value,\n    suffix: this.$2\n  };\n}]];\nparser.table = {\n  gotos: {\n    '0': {\n      aa: 8,\n      ab: 9,\n      ae: 10,\n      af: 11,\n      ag: 12,\n      ai: 13,\n      ak: 14,\n      al: 15,\n      an: 16,\n      ao: 17,\n      ac: 18\n    },\n    '2': {\n      ae: 20,\n      af: 21,\n      ag: 22,\n      ai: 23,\n      ak: 24,\n      am: 25\n    },\n    '9': {\n      ad: 33\n    },\n    '10': {\n      af: 11,\n      ag: 12,\n      ai: 13,\n      ak: 14,\n      al: 15,\n      an: 16,\n      ao: 34\n    },\n    '17': {\n      af: 11,\n      ag: 12,\n      ai: 13,\n      ak: 14,\n      al: 15,\n      an: 35\n    },\n    '19': {\n      ah: 43\n    },\n    '28': {\n      ab: 46,\n      ae: 10,\n      af: 11,\n      ag: 12,\n      ai: 13,\n      ak: 14,\n      al: 15,\n      an: 16,\n      ao: 17,\n      ac: 18\n    },\n    '33': {\n      ae: 10,\n      af: 11,\n      ag: 12,\n      ai: 13,\n      ak: 14,\n      al: 15,\n      an: 16,\n      ao: 17,\n      ac: 47\n    },\n    '34': {\n      af: 11,\n      ag: 12,\n      ai: 13,\n      ak: 14,\n      al: 15,\n      an: 35\n    },\n    '43': {\n      aj: 50\n    },\n    '46': {\n      ad: 33\n    }\n  },\n  action: {\n    '0': {\n      b: [1, undefined, 1],\n      m: [1, undefined, 2],\n      n: [1, undefined, 3],\n      p: [1, undefined, 4],\n      q: [1, undefined, 5],\n      s: [1, undefined, 6],\n      w: [1, undefined, 7]\n    },\n    '1': {\n      n: [1, undefined, 19]\n    },\n    '2': {\n      b: [1, undefined, 1],\n      n: [1, undefined, 3],\n      p: [1, undefined, 4],\n      q: [1, undefined, 5],\n      s: [1, undefined, 6],\n      w: [1, undefined, 7]\n    },\n    '3': {\n      a: [2, 9],\n      r: [2, 9],\n      t: [2, 9],\n      u: [2, 9],\n      v: [2, 9],\n      x: [2, 9],\n      p: [2, 9],\n      q: [2, 9],\n      b: [2, 9],\n      s: [2, 9],\n      m: [2, 9],\n      l: [2, 9]\n    },\n    '4': {\n      a: [2, 11],\n      r: [2, 11],\n      t: [2, 11],\n      u: [2, 11],\n      v: [2, 11],\n      x: [2, 11],\n      p: [2, 11],\n      q: [2, 11],\n      b: [2, 11],\n      s: [2, 11],\n      m: [2, 11],\n      l: [2, 11]\n    },\n    '5': {\n      a: [2, 12],\n      r: [2, 12],\n      t: [2, 12],\n      u: [2, 12],\n      v: [2, 12],\n      x: [2, 12],\n      p: [2, 12],\n      q: [2, 12],\n      b: [2, 12],\n      s: [2, 12],\n      m: [2, 12],\n      l: [2, 12]\n    },\n    '6': {\n      j: [1, undefined, 26],\n      n: [1, undefined, 27]\n    },\n    '7': {\n      a: [2, 10],\n      r: [2, 10],\n      t: [2, 10],\n      u: [2, 10],\n      v: [2, 10],\n      x: [2, 10],\n      p: [2, 10],\n      q: [2, 10],\n      b: [2, 10],\n      s: [2, 10],\n      m: [2, 10],\n      l: [2, 10]\n    },\n    '8': {\n      a: [0],\n      r: [1, undefined, 28]\n    },\n    '9': {\n      a: [2, 1],\n      r: [2, 1],\n      t: [1, undefined, 29],\n      u: [1, undefined, 30],\n      v: [1, undefined, 31],\n      x: [1, undefined, 32]\n    },\n    '10': {\n      a: [2, 38],\n      r: [2, 38],\n      t: [2, 38],\n      u: [2, 38],\n      v: [2, 38],\n      x: [2, 38],\n      b: [1, undefined, 1],\n      m: [1, undefined, 2],\n      p: [1, undefined, 4],\n      q: [1, undefined, 5],\n      s: [1, undefined, 6]\n    },\n    '11': {\n      a: [2, 31],\n      r: [2, 31],\n      t: [2, 31],\n      u: [2, 31],\n      v: [2, 31],\n      x: [2, 31],\n      p: [2, 31],\n      q: [2, 31],\n      b: [2, 31],\n      s: [2, 31],\n      m: [2, 31]\n    },\n    '12': {\n      a: [2, 32],\n      r: [2, 32],\n      t: [2, 32],\n      u: [2, 32],\n      v: [2, 32],\n      x: [2, 32],\n      p: [2, 32],\n      q: [2, 32],\n      b: [2, 32],\n      s: [2, 32],\n      m: [2, 32]\n    },\n    '13': {\n      a: [2, 33],\n      r: [2, 33],\n      t: [2, 33],\n      u: [2, 33],\n      v: [2, 33],\n      x: [2, 33],\n      p: [2, 33],\n      q: [2, 33],\n      b: [2, 33],\n      s: [2, 33],\n      m: [2, 33]\n    },\n    '14': {\n      a: [2, 34],\n      r: [2, 34],\n      t: [2, 34],\n      u: [2, 34],\n      v: [2, 34],\n      x: [2, 34],\n      p: [2, 34],\n      q: [2, 34],\n      b: [2, 34],\n      s: [2, 34],\n      m: [2, 34]\n    },\n    '15': {\n      a: [2, 35],\n      r: [2, 35],\n      t: [2, 35],\n      u: [2, 35],\n      v: [2, 35],\n      x: [2, 35],\n      p: [2, 35],\n      q: [2, 35],\n      b: [2, 35],\n      s: [2, 35],\n      m: [2, 35]\n    },\n    '16': {\n      a: [2, 36],\n      r: [2, 36],\n      t: [2, 36],\n      u: [2, 36],\n      v: [2, 36],\n      x: [2, 36],\n      p: [2, 36],\n      q: [2, 36],\n      b: [2, 36],\n      s: [2, 36],\n      m: [2, 36]\n    },\n    '17': {\n      a: [2, 39],\n      r: [2, 39],\n      t: [2, 39],\n      u: [2, 39],\n      v: [2, 39],\n      x: [2, 39],\n      b: [1, undefined, 1],\n      m: [1, undefined, 2],\n      p: [1, undefined, 4],\n      q: [1, undefined, 5],\n      s: [1, undefined, 6]\n    },\n    '18': {\n      a: [2, 3],\n      r: [2, 3],\n      t: [2, 3],\n      u: [2, 3],\n      v: [2, 3],\n      x: [2, 3]\n    },\n    '19': {\n      c: [1, undefined, 36],\n      d: [1, undefined, 37],\n      e: [1, undefined, 38],\n      f: [1, undefined, 39],\n      g: [1, undefined, 40],\n      h: [1, undefined, 41],\n      i: [1, undefined, 42]\n    },\n    '20': {\n      l: [2, 26]\n    },\n    '21': {\n      l: [2, 27]\n    },\n    '22': {\n      l: [2, 28]\n    },\n    '23': {\n      l: [2, 29]\n    },\n    '24': {\n      l: [2, 30]\n    },\n    '25': {\n      l: [1, undefined, 44]\n    },\n    '26': {\n      k: [1, undefined, 45]\n    },\n    '27': {\n      a: [2, 24],\n      r: [2, 24],\n      t: [2, 24],\n      u: [2, 24],\n      v: [2, 24],\n      x: [2, 24],\n      p: [2, 24],\n      q: [2, 24],\n      b: [2, 24],\n      s: [2, 24],\n      m: [2, 24],\n      l: [2, 24]\n    },\n    '28': {\n      b: [1, undefined, 1],\n      m: [1, undefined, 2],\n      n: [1, undefined, 3],\n      p: [1, undefined, 4],\n      q: [1, undefined, 5],\n      s: [1, undefined, 6],\n      w: [1, undefined, 7]\n    },\n    '29': {\n      n: [2, 5],\n      w: [2, 5],\n      p: [2, 5],\n      q: [2, 5],\n      b: [2, 5],\n      s: [2, 5],\n      m: [2, 5]\n    },\n    '30': {\n      n: [2, 6],\n      w: [2, 6],\n      p: [2, 6],\n      q: [2, 6],\n      b: [2, 6],\n      s: [2, 6],\n      m: [2, 6]\n    },\n    '31': {\n      n: [2, 7],\n      w: [2, 7],\n      p: [2, 7],\n      q: [2, 7],\n      b: [2, 7],\n      s: [2, 7],\n      m: [2, 7]\n    },\n    '32': {\n      n: [2, 8],\n      w: [2, 8],\n      p: [2, 8],\n      q: [2, 8],\n      b: [2, 8],\n      s: [2, 8],\n      m: [2, 8]\n    },\n    '33': {\n      b: [1, undefined, 1],\n      m: [1, undefined, 2],\n      n: [1, undefined, 3],\n      p: [1, undefined, 4],\n      q: [1, undefined, 5],\n      s: [1, undefined, 6],\n      w: [1, undefined, 7]\n    },\n    '34': {\n      a: [2, 40],\n      r: [2, 40],\n      t: [2, 40],\n      u: [2, 40],\n      v: [2, 40],\n      x: [2, 40],\n      b: [1, undefined, 1],\n      m: [1, undefined, 2],\n      p: [1, undefined, 4],\n      q: [1, undefined, 5],\n      s: [1, undefined, 6]\n    },\n    '35': {\n      a: [2, 37],\n      r: [2, 37],\n      t: [2, 37],\n      u: [2, 37],\n      v: [2, 37],\n      x: [2, 37],\n      p: [2, 37],\n      q: [2, 37],\n      b: [2, 37],\n      s: [2, 37],\n      m: [2, 37]\n    },\n    '36': {\n      a: [2, 19],\n      r: [2, 19],\n      t: [2, 19],\n      u: [2, 19],\n      v: [2, 19],\n      x: [2, 19],\n      p: [2, 19],\n      q: [2, 19],\n      b: [2, 19],\n      s: [2, 19],\n      m: [2, 19],\n      l: [2, 19]\n    },\n    '37': {\n      n: [2, 17],\n      o: [2, 17]\n    },\n    '38': {\n      n: [2, 18],\n      o: [2, 18]\n    },\n    '39': {\n      n: [2, 13],\n      o: [2, 13]\n    },\n    '40': {\n      n: [2, 14],\n      o: [2, 14]\n    },\n    '41': {\n      n: [2, 15],\n      o: [2, 15]\n    },\n    '42': {\n      n: [2, 16],\n      o: [2, 16]\n    },\n    '43': {\n      n: [1, undefined, 48],\n      o: [1, undefined, 49]\n    },\n    '44': {\n      a: [2, 25],\n      r: [2, 25],\n      t: [2, 25],\n      u: [2, 25],\n      v: [2, 25],\n      x: [2, 25],\n      p: [2, 25],\n      q: [2, 25],\n      b: [2, 25],\n      s: [2, 25],\n      m: [2, 25]\n    },\n    '45': {\n      l: [1, undefined, 51]\n    },\n    '46': {\n      a: [2, 2],\n      r: [2, 2],\n      t: [1, undefined, 29],\n      u: [1, undefined, 30],\n      v: [1, undefined, 31],\n      x: [1, undefined, 32]\n    },\n    '47': {\n      a: [2, 4],\n      r: [2, 4],\n      t: [2, 4],\n      u: [2, 4],\n      v: [2, 4],\n      x: [2, 4]\n    },\n    '48': {\n      c: [2, 20]\n    },\n    '49': {\n      c: [2, 21]\n    },\n    '50': {\n      c: [1, undefined, 52]\n    },\n    '51': {\n      a: [2, 23],\n      r: [2, 23],\n      t: [2, 23],\n      u: [2, 23],\n      v: [2, 23],\n      x: [2, 23],\n      p: [2, 23],\n      q: [2, 23],\n      b: [2, 23],\n      s: [2, 23],\n      m: [2, 23],\n      l: [2, 23]\n    },\n    '52': {\n      a: [2, 22],\n      r: [2, 22],\n      t: [2, 22],\n      u: [2, 22],\n      v: [2, 22],\n      x: [2, 22],\n      p: [2, 22],\n      q: [2, 22],\n      b: [2, 22],\n      s: [2, 22],\n      m: [2, 22],\n      l: [2, 22]\n    }\n  }\n};\n\nparser.parse = function parse(input, filename) {\n  var self = this,\n      lexer = self.lexer,\n      state,\n      symbol,\n      action,\n      table = self.table,\n      gotos = table.gotos,\n      tableAction = table.action,\n      productions = self.productions,\n      valueStack = [null],\n      // for debug info\n  prefix = filename ? 'in file: ' + filename + ' ' : '',\n      stack = [0];\n  lexer.resetInput(input);\n\n  while (1) {\n    // retrieve state number from top of stack\n    state = stack[stack.length - 1];\n\n    if (!symbol) {\n      symbol = lexer.lex();\n    }\n\n    if (symbol) {\n      // read action for current state and first input\n      action = tableAction[state] && tableAction[state][symbol];\n    } else {\n      action = null;\n    }\n\n    if (!action) {\n      var expected = [],\n          error; //#JSCOVERAGE_IF\n\n      if (tableAction[state]) {\n        for (var symbolForState in tableAction[state]) {\n          expected.push(self.lexer.mapReverseSymbol(symbolForState));\n        }\n      }\n\n      error = prefix + 'syntax error at line ' + lexer.lineNumber + ':\\n' + lexer.showDebugInfo() + '\\n' + 'expect ' + expected.join(', ');\n      throw new Error(error);\n    }\n\n    switch (action[GrammarConst.TYPE_INDEX]) {\n      case GrammarConst.SHIFT_TYPE:\n        stack.push(symbol);\n        valueStack.push(lexer.text); // push state\n\n        stack.push(action[GrammarConst.TO_INDEX]); // allow to read more\n\n        symbol = null;\n        break;\n\n      case GrammarConst.REDUCE_TYPE:\n        var production = productions[action[GrammarConst.PRODUCTION_INDEX]],\n            reducedSymbol = production.symbol || production[0],\n            reducedAction = production.action || production[2],\n            reducedRhs = production.rhs || production[1],\n            len = reducedRhs.length,\n            i = 0,\n            ret,\n            $$ = valueStack[valueStack.length - len]; // default to $$ = $1\n\n        ret = undefined;\n        self.$$ = $$;\n\n        for (; i < len; i++) {\n          self['$' + (len - i)] = valueStack[valueStack.length - 1 - i];\n        }\n\n        if (reducedAction) {\n          ret = reducedAction.call(self);\n        }\n\n        if (ret !== undefined) {\n          $$ = ret;\n        } else {\n          $$ = self.$$;\n        }\n\n        stack = stack.slice(0, -1 * len * 2);\n        valueStack = valueStack.slice(0, -1 * len);\n        stack.push(reducedSymbol);\n        valueStack.push($$);\n        var newState = gotos[stack[stack.length - 2]][stack[stack.length - 1]];\n        stack.push(newState);\n        break;\n\n      case GrammarConst.ACCEPT_TYPE:\n        return $$;\n    }\n  }\n};\n/**\n * @ignore\n * css3 selector engine for ie6-8\n * @author yiminghe@gmail.com\n */\n\n\nvar EXPANDO_SELECTOR_KEY = '_ks_data_selector_id_',\n    caches = {},\n    isContextXML,\n    uuid = 0,\n    subMatchesCache = {},\n    getAttr = function getAttr(el, name) {\n  if (isContextXML) {\n    return util.getSimpleAttr(el, name);\n  } else {\n    return util.attr(el, name);\n  }\n},\n    hasSingleClass = util.hasSingleClass,\n    isTag = util.isTag,\n    aNPlusB = /^(([+-]?(?:\\d+)?)?n)?([+-]?\\d+)?$/; // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\n\nvar unescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n    unescapeFn = function unescapeFn(_, escaped) {\n  var high = '0x' + escaped - 0x10000; // NaN means non-codepoint\n\n  return isNaN(high) ? escaped : // BMP codepoint\n  high < 0 ? String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n  String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n};\n\nvar matchExpr;\nvar pseudoFnExpr = {\n  'nth-child': function nthChild(el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          count = 0,\n          child,\n          ret,\n          len = childNodes.length;\n\n      for (; count < len; count++) {\n        child = childNodes[count];\n\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-last-child': function nthLastChild(el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          len = childNodes.length,\n          count = len - 1,\n          child,\n          ret;\n\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-of-type': function nthOfType(el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          elType = el.tagName,\n          count = 0,\n          child,\n          ret,\n          len = childNodes.length;\n\n      for (; count < len; count++) {\n        child = childNodes[count];\n\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-last-of-type': function nthLastOfType(el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          len = childNodes.length,\n          elType = el.tagName,\n          count = len - 1,\n          child,\n          ret;\n\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  lang: function lang(el, _lang) {\n    var elLang;\n    _lang = unEscape(_lang.toLowerCase());\n\n    do {\n      if (elLang = isContextXML ? el.getAttribute('xml:lang') || el.getAttribute('lang') : el.lang) {\n        elLang = elLang.toLowerCase();\n        return elLang === _lang || elLang.indexOf(_lang + '-') === 0;\n      }\n    } while ((el = el.parentNode) && el.nodeType === 1);\n\n    return false;\n  },\n  not: function not(el, negationArg) {\n    return !matchExpr[negationArg.t](el, negationArg.value);\n  }\n};\nvar pseudoIdentExpr = {\n  empty: function empty(el) {\n    var childNodes = el.childNodes,\n        index = 0,\n        len = childNodes.length,\n        child,\n        nodeType;\n\n    for (; index < len; index++) {\n      child = childNodes[index];\n      nodeType = child.nodeType; // only element nodes and content nodes\n      // (such as Dom [Dom-LEVEL-3-CORE] text nodes,\n      // CDATA nodes, and entity references\n\n      if (nodeType === 1 || nodeType === 3 || nodeType === 4 || nodeType === 5) {\n        return 0;\n      }\n    }\n\n    return 1;\n  },\n  root: function root(el) {\n    if (el.nodeType === 9) {\n      return true;\n    }\n\n    return el.ownerDocument && el === el.ownerDocument.documentElement;\n  },\n  'first-child': function firstChild(el) {\n    return pseudoFnExpr['nth-child'](el, 1);\n  },\n  'last-child': function lastChild(el) {\n    return pseudoFnExpr['nth-last-child'](el, 1);\n  },\n  'first-of-type': function firstOfType(el) {\n    return pseudoFnExpr['nth-of-type'](el, 1);\n  },\n  'last-of-type': function lastOfType(el) {\n    return pseudoFnExpr['nth-last-of-type'](el, 1);\n  },\n  'only-child': function onlyChild(el) {\n    return pseudoIdentExpr['first-child'](el) && pseudoIdentExpr['last-child'](el);\n  },\n  'only-of-type': function onlyOfType(el) {\n    return pseudoIdentExpr['first-of-type'](el) && pseudoIdentExpr['last-of-type'](el);\n  },\n  focus: function focus(el) {\n    var doc = el.ownerDocument;\n    return doc && el === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(el.type || el.href || el.tabIndex >= 0);\n  },\n  target: function target(el) {\n    var hash = location.hash;\n    return hash && hash.slice(1) === getAttr(el, 'id');\n  },\n  enabled: function enabled(el) {\n    return !el.disabled;\n  },\n  disabled: function disabled(el) {\n    return el.disabled;\n  },\n  checked: function checked(el) {\n    var nodeName = el.nodeName.toLowerCase();\n    return nodeName === 'input' && el.checked || nodeName === 'option' && el.selected;\n  }\n};\nvar attributeExpr = {\n  '~=': function _(elValue, value) {\n    if (!value || value.indexOf(' ') > -1) {\n      return 0;\n    }\n\n    return (' ' + elValue + ' ').indexOf(' ' + value + ' ') !== -1;\n  },\n  '|=': function _(elValue, value) {\n    return (' ' + elValue).indexOf(' ' + value + '-') !== -1;\n  },\n  '^=': function _(elValue, value) {\n    return value && util.startsWith(elValue, value);\n  },\n  '$=': function $(elValue, value) {\n    return value && util.endsWith(elValue, value);\n  },\n  '*=': function _(elValue, value) {\n    return value && elValue.indexOf(value) !== -1;\n  },\n  '=': function _(elValue, value) {\n    return elValue === value;\n  }\n};\nvar relativeExpr = {\n  '>': {\n    dir: 'parentNode',\n    immediate: 1\n  },\n  ' ': {\n    dir: 'parentNode'\n  },\n  '+': {\n    dir: 'previousSibling',\n    immediate: 1\n  },\n  '~': {\n    dir: 'previousSibling'\n  }\n};\nmatchExpr = {\n  tag: isTag,\n  cls: hasSingleClass,\n  id: function id(el, value) {\n    return getAttr(el, 'id') === value;\n  },\n  attrib: function attrib(el, value) {\n    var name = value.ident;\n\n    if (!isContextXML) {\n      name = name.toLowerCase();\n    }\n\n    var elValue = getAttr(el, name);\n    var match = value.match;\n\n    if (!match && elValue !== undefined) {\n      return 1;\n    } else if (match) {\n      if (elValue === undefined) {\n        return 0;\n      }\n\n      var matchFn = attributeExpr[match];\n\n      if (matchFn) {\n        return matchFn(elValue + '', value.value + '');\n      }\n    }\n\n    return 0;\n  },\n  pseudo: function pseudo(el, value) {\n    var fn, fnStr, ident;\n\n    if (fnStr = value.fn) {\n      if (!(fn = pseudoFnExpr[fnStr])) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + fnStr);\n      }\n\n      return fn(el, value.param);\n    }\n\n    if (ident = value.ident) {\n      if (!pseudoIdentExpr[ident]) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + ident);\n      }\n\n      return pseudoIdentExpr[ident](el);\n    }\n\n    return 0;\n  }\n};\n\nfunction unEscape(str) {\n  return str.replace(unescape, unescapeFn);\n}\n\nparser.lexer.yy = {\n  trim: util.trim,\n  unEscape: unEscape,\n  unEscapeStr: function unEscapeStr(str) {\n    return this.unEscape(str.slice(1, -1));\n  }\n};\n\nfunction resetStatus() {\n  subMatchesCache = {};\n}\n\nfunction dir(el, direction) {\n  do {\n    el = el[direction];\n  } while (el && el.nodeType !== 1);\n\n  return el;\n}\n\nfunction getAb(param) {\n  var a = 0,\n      match,\n      b = 0;\n\n  if (typeof param === 'number') {\n    b = param;\n  } else if (param === 'odd') {\n    a = 2;\n    b = 1;\n  } else if (param === 'even') {\n    a = 2;\n    b = 0;\n  } else if (match = param.replace(/\\s/g, '').match(aNPlusB)) {\n    if (match[1]) {\n      a = parseInt(match[2], 10);\n\n      if (isNaN(a)) {\n        if (match[2] === '-') {\n          a = -1;\n        } else {\n          a = 1;\n        }\n      }\n    } else {\n      a = 0;\n    }\n\n    b = parseInt(match[3], 10) || 0;\n  }\n\n  return {\n    a: a,\n    b: b\n  };\n}\n\nfunction matchIndexByAb(index, a, b, eq) {\n  if (a === 0) {\n    if (index === b) {\n      return eq;\n    }\n  } else {\n    if ((index - b) / a >= 0 && (index - b) % a === 0 && eq) {\n      return 1;\n    }\n  }\n\n  return undefined;\n}\n\nfunction isXML(elem) {\n  var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n  return documentElement ? documentElement.nodeName.toLowerCase() !== 'html' : false;\n}\n\nfunction matches(str, seeds) {\n  return select(str, null, seeds);\n}\n\nfunction singleMatch(el, match) {\n  if (!match) {\n    return true;\n  }\n\n  if (!el) {\n    return false;\n  }\n\n  if (el.nodeType === 9) {\n    return false;\n  }\n\n  var matched = 1,\n      matchSuffix = match.suffix,\n      matchSuffixLen,\n      matchSuffixIndex;\n\n  if (match.t === 'tag') {\n    matched &= matchExpr.tag(el, match.value);\n  }\n\n  if (matched && matchSuffix) {\n    matchSuffixLen = matchSuffix.length;\n    matchSuffixIndex = 0;\n\n    for (; matched && matchSuffixIndex < matchSuffixLen; matchSuffixIndex++) {\n      var singleMatchSuffix = matchSuffix[matchSuffixIndex],\n          singleMatchSuffixType = singleMatchSuffix.t;\n\n      if (matchExpr[singleMatchSuffixType]) {\n        matched &= matchExpr[singleMatchSuffixType](el, singleMatchSuffix.value);\n      }\n    }\n  }\n\n  return matched;\n} // match by adjacent immediate single selector match\n\n\nfunction matchImmediate(el, match) {\n  var matched = 1,\n      startEl = el,\n      relativeOp,\n      startMatch = match;\n\n  do {\n    matched &= singleMatch(el, match);\n\n    if (matched) {\n      // advance\n      match = match && match.prev;\n\n      if (!match) {\n        return true;\n      }\n\n      relativeOp = relativeExpr[match.nextCombinator];\n      el = dir(el, relativeOp.dir);\n\n      if (!relativeOp.immediate) {\n        return {\n          // advance for non-immediate\n          el: el,\n          match: match\n        };\n      }\n    } else {\n      relativeOp = relativeExpr[match.nextCombinator];\n\n      if (relativeOp.immediate) {\n        // retreat but advance startEl\n        return {\n          el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n          match: startMatch\n        };\n      } else {\n        // advance (before immediate match + jump unmatched)\n        return {\n          el: el && dir(el, relativeOp.dir),\n          match: match\n        };\n      }\n    }\n  } while (el); // only occur when match immediate\n\n\n  return {\n    el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n    match: startMatch\n  };\n} // find fixed part, fixed with seeds\n\n\nfunction findFixedMatchFromHead(el, head) {\n  var relativeOp,\n      cur = head;\n\n  do {\n    if (!singleMatch(el, cur)) {\n      return null;\n    }\n\n    cur = cur.prev;\n\n    if (!cur) {\n      return true;\n    }\n\n    relativeOp = relativeExpr[cur.nextCombinator];\n    el = dir(el, relativeOp.dir);\n  } while (el && relativeOp.immediate);\n\n  if (!el) {\n    return null;\n  }\n\n  return {\n    el: el,\n    match: cur\n  };\n}\n\nfunction genId(el) {\n  var selectorId;\n\n  if (isContextXML) {\n    if (!(selectorId = el.getAttribute(EXPANDO_SELECTOR_KEY))) {\n      el.setAttribute(EXPANDO_SELECTOR_KEY, selectorId = +new Date() + '_' + ++uuid);\n    }\n  } else {\n    if (!(selectorId = el[EXPANDO_SELECTOR_KEY])) {\n      selectorId = el[EXPANDO_SELECTOR_KEY] = +new Date() + '_' + ++uuid;\n    }\n  }\n\n  return selectorId;\n}\n\nfunction matchSub(el, match) {\n  var selectorId = genId(el),\n      matchKey;\n  matchKey = selectorId + '_' + (match.order || 0);\n\n  if (matchKey in subMatchesCache) {\n    return subMatchesCache[matchKey];\n  }\n\n  subMatchesCache[matchKey] = matchSubInternal(el, match);\n  return subMatchesCache[matchKey];\n} // recursive match by sub selector string from right to left\n// grouped by immediate selectors\n\n\nfunction matchSubInternal(el, match) {\n  var matchImmediateRet = matchImmediate(el, match);\n\n  if (matchImmediateRet === true) {\n    return true;\n  } else {\n    el = matchImmediateRet.el;\n    match = matchImmediateRet.match;\n\n    while (el) {\n      if (matchSub(el, match)) {\n        return true;\n      }\n\n      el = dir(el, relativeExpr[match.nextCombinator].dir);\n    }\n\n    return false;\n  }\n}\n\nfunction select(str, context, seeds) {\n  if (!caches[str]) {\n    caches[str] = parser.parse(str);\n  }\n\n  var selector = caches[str],\n      groupIndex = 0,\n      groupLen = selector.length,\n      contextDocument,\n      group,\n      ret = [];\n\n  if (seeds) {\n    context = context || seeds[0].ownerDocument;\n  }\n\n  contextDocument = context && context.ownerDocument || typeof document !== 'undefined' && document;\n\n  if (context && context.nodeType === 9 && !contextDocument) {\n    contextDocument = context;\n  }\n\n  context = context || contextDocument;\n  isContextXML = isXML(context);\n\n  for (; groupIndex < groupLen; groupIndex++) {\n    resetStatus();\n    group = selector[groupIndex];\n    var suffix = group.suffix,\n        suffixIndex,\n        suffixLen,\n        seedsIndex,\n        mySeeds = seeds,\n        seedsLen,\n        id = null;\n\n    if (!mySeeds) {\n      if (suffix && !isContextXML) {\n        suffixIndex = 0;\n        suffixLen = suffix.length;\n\n        for (; suffixIndex < suffixLen; suffixIndex++) {\n          var singleSuffix = suffix[suffixIndex];\n\n          if (singleSuffix.t === 'id') {\n            id = singleSuffix.value;\n            break;\n          }\n        }\n      }\n\n      if (id) {\n        // http://yiminghe.github.io/lab/playground/fragment-selector/selector.html\n        var doesNotHasById = !context.getElementById,\n            contextInDom = util.contains(contextDocument, context),\n            tmp = doesNotHasById ? contextInDom ? contextDocument.getElementById(id) : null : context.getElementById(id); // id bug\n        // https://github.com/kissyteam/kissy/issues/67\n\n        if (!tmp && doesNotHasById || tmp && getAttr(tmp, 'id') !== id) {\n          var tmps = util.getElementsByTagName('*', context),\n              tmpLen = tmps.length,\n              tmpI = 0;\n\n          for (; tmpI < tmpLen; tmpI++) {\n            tmp = tmps[tmpI];\n\n            if (getAttr(tmp, 'id') === id) {\n              mySeeds = [tmp];\n              break;\n            }\n          }\n\n          if (tmpI === tmpLen) {\n            mySeeds = [];\n          }\n        } else {\n          if (contextInDom && tmp && context !== contextDocument) {\n            tmp = util.contains(context, tmp) ? tmp : null;\n          }\n\n          mySeeds = tmp ? [tmp] : [];\n        }\n      } else {\n        mySeeds = util.getElementsByTagName(group.value || '*', context);\n      }\n    }\n\n    seedsIndex = 0;\n    seedsLen = mySeeds.length;\n\n    if (!seedsLen) {\n      continue;\n    }\n\n    for (; seedsIndex < seedsLen; seedsIndex++) {\n      var seed = mySeeds[seedsIndex];\n      var matchHead = findFixedMatchFromHead(seed, group);\n\n      if (matchHead === true) {\n        ret.push(seed);\n      } else if (matchHead) {\n        if (matchSub(matchHead.el, matchHead.match)) {\n          ret.push(seed);\n        }\n      }\n    }\n  }\n\n  if (groupLen > 1) {\n    ret = util.unique(ret);\n  }\n\n  return ret;\n}\n\nselect.parse = function (str) {\n  return parser.parse(str);\n};\n\nselect.matches = matches;\nselect.util = util;\n/**\n * @ignore\n * note 2013-03-28\n *  - use recursive call to replace backtracking algorithm\n *\n * refer\n *  - http://www.w3.org/TR/selectors/\n *  - http://www.impressivewebs.com/browser-support-css3-selectors/\n *  - http://blogs.msdn.com/ie/archive/2010/05/13/the-css-corner-css3-selectors.aspx\n *  - http://sizzlejs.com/\n */\n\nexports.default = select;","map":null,"metadata":{},"sourceType":"script"}