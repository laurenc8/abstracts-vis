import { createElement, createRef, forwardRef, useState, useImperativeHandle, useRef } from 'react';
import * as styleAttr from 'style-attr';
import querySelectorAll from 'query-selector';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var ELEMENT_NODE = 1;
var DOCUMENT_POSITION = {
    DISCONNECTED: 1,
    PRECEDING: 2,
    FOLLOWING: 4,
    CONTAINS: 8,
    CONTAINED_BY: 16,
    IMPLEMENTATION_SPECIFIC: 32,
};
var EVENT_NAME_MAPPING = {
    blur: "onBlur",
    change: "onChange",
    click: "onClick",
    contextmenu: "onContextMenu",
    copy: "onCopy",
    cut: "onCut",
    doubleclick: "onDoubleClick",
    drag: "onDrag",
    dragend: "onDragEnd",
    dragenter: "onDragEnter",
    dragexit: "onDragExit",
    dragleave: "onDragLeave",
    dragover: "onDragOver",
    dragstart: "onDragStart",
    drop: "onDrop",
    error: "onError",
    focus: "onFocus",
    input: "onInput",
    keydown: "onKeyDown",
    keypress: "onKeyPress",
    keyup: "onKeyUp",
    load: "onLoad",
    mousedown: "onMouseDown",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousemove: "onMouseMove",
    mouseout: "onMouseOut",
    mouseover: "onMouseOver",
    mouseup: "onMouseUp",
    paste: "onPaste",
    scroll: "onScroll",
    submit: "onSubmit",
    touchcancel: "onTouchCancel",
    touchend: "onTouchEnd",
    touchmove: "onTouchMove",
    touchstart: "onTouchStart",
    wheel: "onWheel",
};

var HYPHEN_EXP = /-+([a-z])/gi;
function camelCase(str) {
    var camelCased = str.replace(HYPHEN_EXP, function (match, c, offset) {
        if (offset !== 0) {
            return c.toUpperCase();
        }
        else {
            return c;
        }
    });
    HYPHEN_EXP.lastIndex = 0;
    return camelCased;
}
function isString(value) {
    return typeof value === "string";
}
function isUndefined(value) {
    return typeof value === "undefined";
}
var eventToPropName = function (name) {
    return (EVENT_NAME_MAPPING[name] ||
        "on" + name.slice(0, 1).toUpperCase() + name.slice(1));
};
var SKIP_ATTR_EXP = [/^data-/, /^aria-/];
var attrToPropName = function (name) {
    if (SKIP_ATTR_EXP.some(function (expr) { return expr.test(name); })) {
        return name;
    }
    else if (name === "class") {
        return "className";
    }
    else {
        return camelCase(name);
    }
};
function styleToPropName(name) {
    var camel = camelCase(name);
    // Detect if the style property is already camelCased
    // To not convert Webkit*, Moz* and O* to lowercase
    if (camel.charAt(0).toUpperCase() === name.charAt(0)) {
        return name.charAt(0) + camel.slice(1);
    }
    else if (name.charAt(0) === "-") {
        return camel.indexOf("ms") === 0
            ? camel
            : camel.charAt(0).toUpperCase() + camel.slice(1);
    }
    else {
        return camel;
    }
}

var generateId = function () {
    return Math.random().toString(36).substr(2, 9);
};
var mapEventListener = function (self, listeners) {
    return function (syntheticEvent) {
        var event;
        if (syntheticEvent) {
            event = syntheticEvent.nativeEvent;
            event.syntheticEvent = syntheticEvent;
        }
        listeners.forEach(function (listener) {
            listener.call(self, event);
        });
    };
};
function isAncestor(source, target) {
    while (target.parentNode) {
        target = target.parentNode;
        if (target === source) {
            return true;
        }
    }
    return false;
}
function getFirstNodeByOrder(nodes, nodeOne, nodeTwo) {
    return nodes.reduce(function (result, node) {
        if (result !== false) {
            return result;
        }
        else if (node === nodeOne) {
            return nodeOne;
        }
        else if (node === nodeTwo) {
            return nodeTwo;
        }
        else if (node.childNodes) {
            return getFirstNodeByOrder(node.childNodes, nodeOne, nodeTwo);
        }
        else {
            return false;
        }
    }, false);
}
function eitherContains(left, right) {
    return isAncestor(left, right)
        ? DOCUMENT_POSITION.CONTAINED_BY + DOCUMENT_POSITION.FOLLOWING
        : isAncestor(right, left)
            ? DOCUMENT_POSITION.CONTAINS + DOCUMENT_POSITION.PRECEDING
            : false;
}
function getRootNode(node) {
    while (node.parentNode) {
        node = node.parentNode;
    }
    return node;
}
var FauxStyle = /** @class */ (function () {
    function FauxStyle(ref, style) {
        var _this = this;
        if (style === void 0) { style = {}; }
        this.ref = createRef();
        this.setProperty = function (name, value) {
            var _a;
            var hasUpdate = _this.getPropertyValue(name) !== value;
            _this.style[styleToPropName(name)] = value;
            if (hasUpdate) {
                (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.style.setProperty(name, value);
            }
        };
        this.getPropertyValue = function (name) {
            var _a;
            return (_a = _this.style[styleToPropName(name)]) !== null && _a !== void 0 ? _a : "";
        };
        this.removeProperty = function (name) {
            var _a;
            var key = styleToPropName(name);
            var old = _this.style[key];
            var hasUpdate = !isUndefined(old);
            delete _this.style[key];
            if (hasUpdate) {
                (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.style.removeProperty(name);
            }
            return old !== null && old !== void 0 ? old : "";
        };
        this.ref = ref;
        this.style = style;
    }
    return FauxStyle;
}());
var D3Element = /** @class */ (function () {
    function D3Element(nodeName, initialValues, isRoot) {
        var _this = this;
        if (isRoot === void 0) { isRoot = false; }
        var _a, _b, _c;
        this.ref = createRef();
        this.mountRef = createRef();
        this.setAttribute = function (name, value) {
            var _a;
            if (name === "style") {
                if (isString(value)) {
                    var styles = styleAttr.parse(value);
                    for (var key in styles) {
                        _this.style.setProperty(key, styles[key]);
                    }
                }
            }
            else {
                var hasUpdate = _this.getAttribute(name) !== value;
                _this.attrs[attrToPropName(name)] = value;
                if (hasUpdate) {
                    (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute(name, value);
                }
            }
        };
        this.setAttributeNS = function (ns) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return _this.setAttribute.apply(_this, args);
        };
        this.getAttribute = function (name) {
            return _this.attrs[attrToPropName(name)];
        };
        this.getAttributeNS = function (ns) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return _this.getAttribute.apply(_this, args);
        };
        this.getAttributeNode = function (name) {
            var value = _this.getAttribute(name);
            if (!isUndefined(value)) {
                return {
                    value: value,
                    specified: true,
                };
            }
            return null;
        };
        this.getAttributeNodeNS = function (ns) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return _this.getAttributeNode.apply(_this, args);
        };
        this.removeAttribute = function (name) {
            var _a;
            var hasUpdate = !isUndefined(_this.attrs[attrToPropName(name)]);
            delete _this.attrs[attrToPropName(name)];
            if (hasUpdate) {
                (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.removeAttribute(name);
            }
        };
        this.removeAttributeNS = function (ns) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return _this.removeAttribute.apply(_this, args);
        };
        this.addEventListener = function (name, fn) {
            var prop = eventToPropName(name);
            _this.eventListeners[prop] = _this.eventListeners[prop] || [];
            _this.eventListeners[prop].push(fn);
        };
        this.removeEventListener = function (name, fn) {
            var listeners = _this.eventListeners[eventToPropName(name)];
            if (listeners) {
                var match = listeners.indexOf(fn);
                if (match !== -1) {
                    listeners.splice(match, 1);
                }
            }
        };
        this.getElementsByTagNameNS = function (ns, nodeName) {
            return _this.getElementsByTagName(nodeName);
        };
        this.getElementByIdNS = function (ns, id) { return _this.getElementById(id); };
        this.getBoundingClientRect = function () {
            var _a;
            return (_a = _this.ref.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        };
        this.Mounter = forwardRef(function (props, ref) {
            var _a = useState({}); _a[0]; var setFlush = _a[1];
            useImperativeHandle(ref, function () { return ({
                flush: function () { return setFlush({}); },
            }); }, [setFlush]);
            return _this.renderElement();
        });
        this.id = generateId();
        this.isRoot = isRoot;
        this.nodeName = nodeName;
        this.nodeType = (_a = initialValues === null || initialValues === void 0 ? void 0 : initialValues.nodeType) !== null && _a !== void 0 ? _a : ELEMENT_NODE;
        this.parentNode = initialValues === null || initialValues === void 0 ? void 0 : initialValues.parentNode;
        this.childNodes = [];
        this.text = "";
        this.attrs = (_b = initialValues === null || initialValues === void 0 ? void 0 : initialValues.attrs) !== null && _b !== void 0 ? _b : {};
        this.style = new FauxStyle(this.ref, (_c = initialValues === null || initialValues === void 0 ? void 0 : initialValues.styles) !== null && _c !== void 0 ? _c : {});
        this.eventListeners = {};
    }
    D3Element.prototype.getAttr = function () {
        return __assign({}, this.attrs);
    };
    D3Element.prototype.getStyle = function () {
        return __assign({}, this.style.style);
    };
    D3Element.prototype.appendChild = function (el) {
        var _a;
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
        el.parentNode = this;
        this.childNodes.push(el);
        (_a = this.mountRef.current) === null || _a === void 0 ? void 0 : _a.flush();
        return el;
    };
    D3Element.prototype.insertBefore = function (el, before) {
        var _a;
        var index = this.childNodes.indexOf(before);
        el.parentNode = this;
        if (index !== -1) {
            this.childNodes.splice(index, 0, el);
        }
        else {
            this.childNodes.push(el);
        }
        (_a = this.mountRef.current) === null || _a === void 0 ? void 0 : _a.flush();
        return el;
    };
    D3Element.prototype.removeChild = function (child) {
        var _a;
        var target = this.childNodes.indexOf(child);
        this.childNodes.splice(target, 1);
        (_a = this.mountRef.current) === null || _a === void 0 ? void 0 : _a.flush();
    };
    D3Element.prototype.querySelector = function (selector) {
        return this.querySelectorAll(selector)[0] || null;
    };
    D3Element.prototype.querySelectorAll = function (selector) {
        if (!selector) {
            throw new Error("Not enough arguments");
        }
        return querySelectorAll(selector, this);
    };
    D3Element.prototype.getElementsByTagName = function (nodeName) {
        var children = this.children;
        if (children.length === 0) {
            return [];
        }
        else {
            var matches = void 0;
            if (nodeName !== "*") {
                matches = children.filter(function (el) { return el.nodeName === nodeName; });
            }
            else {
                matches = children;
            }
            var childMatches = children.map(function (el) {
                return el.getElementsByTagName(nodeName);
            });
            return matches.concat.apply(matches, childMatches);
        }
    };
    D3Element.prototype.getElementById = function (id) {
        var children = this.children;
        if (children.length === 0) {
            return null;
        }
        else {
            var match = children.find(function (el) { return el.getAttribute("id") === id; });
            if (match) {
                return match;
            }
            else {
                var childMatches = children.map(function (el) { return el.getElementById(id); });
                return childMatches.find(function (match) { return match !== null; }) || null;
            }
        }
    };
    D3Element.prototype.cloneNode = function (deep) {
        if (deep === void 0) { deep = true; }
        var el = new D3Element(this.nodeName, {
            nodeType: this.nodeType,
            parentNode: this.parentNode,
            attrs: this.getAttr(),
            styles: this.getStyle(),
        });
        if (deep) {
            el.childNodes = this.childNodes.map(function (c) {
                var childEl = c.cloneNode(true);
                childEl.parentNode = el;
                return childEl;
            });
        }
        return el;
    };
    D3Element.prototype.compareDocumentPosition = function (other) {
        if (this === other) {
            return 0;
        }
        var referenceRoot = getRootNode(this);
        var otherRoot = getRootNode(other);
        if (referenceRoot !== otherRoot) {
            return DOCUMENT_POSITION.DISCONNECTED;
        }
        var result = eitherContains(this, other);
        if (result) {
            return result;
        }
        var first = getFirstNodeByOrder([referenceRoot], this, other);
        return first === this
            ? DOCUMENT_POSITION.FOLLOWING
            : first === other
                ? DOCUMENT_POSITION.PRECEDING
                : DOCUMENT_POSITION.DISCONNECTED;
    };
    D3Element.prototype.createSVGPoint = function () {
        var _a;
        return (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.createSVGPoint();
    };
    D3Element.prototype.getScreenCTM = function () {
        var _a;
        return (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.getScreenCTM();
    };
    Object.defineProperty(D3Element.prototype, "ownerDocument", {
        get: function () {
            return FauxDocument;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(D3Element.prototype, "ownerSVGElement", {
        get: function () {
            var target = this;
            while (target.parentNode) {
                target = target.parentNode;
                if (target.nodeName === "svg") {
                    return target;
                }
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(D3Element.prototype, "nextSibling", {
        get: function () {
            var _a;
            var siblings = (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.children;
            if (!siblings)
                return;
            var me = siblings.indexOf(this);
            return siblings[me + 1];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(D3Element.prototype, "previousSibling", {
        get: function () {
            var _a;
            var siblings = (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.children;
            if (!siblings)
                return;
            var me = siblings.indexOf(this);
            return siblings[me - 1];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(D3Element.prototype, "clientLeft", {
        get: function () {
            var _a;
            return (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.clientLeft;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(D3Element.prototype, "clientTop", {
        get: function () {
            var _a;
            return (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.clientTop;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(D3Element.prototype, "innerHTML", {
        get: function () {
            return this.text;
        },
        set: function (text) {
            this.text = text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(D3Element.prototype, "textContent", {
        get: function () {
            return this.text;
        },
        set: function (text) {
            this.text = text;
            if (this.ref.current) {
                this.ref.current.textContent = text;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(D3Element.prototype, "children", {
        get: function () {
            // So far nodes created by this library are all of nodeType 1 (elements),
            // but this could change in the future.
            return this.childNodes.filter(function (el) {
                if (!el.nodeType) {
                    // It's a React element, we always add it
                    return true;
                }
                // It's a HTML node. We want to filter to have only nodes with type 1
                return el.nodeType === ELEMENT_NODE;
            });
        },
        enumerable: false,
        configurable: true
    });
    D3Element.prototype.toReact = function () {
        return createElement(this.Mounter, {
            ref: this.mountRef,
            key: this.id,
        });
    };
    D3Element.prototype.renderElement = function () {
        var _this = this;
        if (!this.isRoot && !this.parentNode)
            return null;
        var attrs = this.getAttr();
        var style = this.getStyle();
        return createElement(this.nodeName, __assign(__assign(__assign({}, attrs), Object.keys(this.eventListeners).reduce(function (acc, k) {
            acc[k] = mapEventListener(_this, _this.eventListeners[k]);
            return acc;
        }, {})), { style: style, ref: this.ref, key: this.id }), this.text || this.children.map(function (el) { return el.toReact(); }));
    };
    return D3Element;
}());
var FauxWindow = {
    getComputedStyle: function (node) { return ({
        getPropertyValue: node.style.getPropertyValue,
    }); },
};
var FauxDocument = {
    Element: D3Element,
    defaultView: FauxWindow,
    createElement: function (nodeName) { return new D3Element(nodeName); },
    createElementNS: function (ns, nodeName) {
        return this.createElement(nodeName);
    },
    // The selector engine tries to validate with this, but we don't care.
    // 8 = DOCUMENT_POSITION_CONTAINS, so we say all nodes are in this document.
    compareDocumentPosition: function () { return DOCUMENT_POSITION.CONTAINS; },
};

var d3Element = function (name) {
    return new D3Element(name, undefined, true);
};
var useD3 = function (recipe, deps) {
    var resRef = useRef(null);
    var depsRef = useRef(deps);
    if (depsRef.current.length === deps.length &&
        depsRef.current.every(function (d, i) { return d === deps[i]; })) {
        return resRef.current || (resRef.current = recipe(d3Element));
    }
    resRef.current = recipe(d3Element);
    depsRef.current = deps;
    return resRef.current;
};

export { useD3 };
